/*++

Copyright (C) 2025 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of MC Driver Spinnaker. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 2.0.0

*/

#include "libmcdriver_spinnaker_abi.hpp"
#include "libmcdriver_spinnaker_interfaces.hpp"
#include "libmcdriver_spinnaker_interfaceexception.hpp"

#include <map>

using namespace LibMCDriver_Spinnaker::Impl;

LibMCDriver_SpinnakerResult handleLibMCDriver_SpinnakerException(IBase * pIBaseClass, ELibMCDriver_SpinnakerInterfaceException & Exception)
{
	LibMCDriver_SpinnakerResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_SpinnakerResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCDriver_SpinnakerResult errorCode = LIBMCDRIVER_SPINNAKER_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_SpinnakerResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCDriver_SpinnakerResult errorCode = LIBMCDRIVER_SPINNAKER_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Driver
**************************************************************************************************************************/
LibMCDriver_SpinnakerResult libmcdriver_spinnaker_driver_configure(LibMCDriver_Spinnaker_Driver pDriver, const char * pConfigurationString)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (pConfigurationString == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sConfigurationString(pConfigurationString);
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pIDriver->Configure(sConfigurationString);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_driver_getname(LibMCDriver_Spinnaker_Driver pDriver, const LibMCDriver_Spinnaker_uint32 nNameBufferSize, LibMCDriver_Spinnaker_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sName("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIDriver->GetName();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIDriver->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCDriver_Spinnaker_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_driver_gettype(LibMCDriver_Spinnaker_Driver pDriver, const LibMCDriver_Spinnaker_uint32 nTypeBufferSize, LibMCDriver_Spinnaker_uint32* pTypeNeededChars, char * pTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pTypeBuffer) && !(pTypeNeededChars) )
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sType("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTypeBuffer == nullptr);
		if (isCacheCall) {
			sType = pIDriver->GetType();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
			cache->retrieveData (sType);
			pIDriver->_setCache (nullptr);
		}
		
		if (pTypeNeededChars)
			*pTypeNeededChars = (LibMCDriver_Spinnaker_uint32) (sType.size()+1);
		if (pTypeBuffer) {
			if (sType.size() >= nTypeBufferSize)
				throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_BUFFERTOOSMALL);
			for (size_t iType = 0; iType < sType.size(); iType++)
				pTypeBuffer[iType] = sType[iType];
			pTypeBuffer[sType.size()] = 0;
		}
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_driver_getversion(LibMCDriver_Spinnaker_Driver pDriver, LibMCDriver_Spinnaker_uint32 * pMajor, LibMCDriver_Spinnaker_uint32 * pMinor, LibMCDriver_Spinnaker_uint32 * pMicro, const LibMCDriver_Spinnaker_uint32 nBuildBufferSize, LibMCDriver_Spinnaker_uint32* pBuildNeededChars, char * pBuildBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (!pMajor)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if ( (!pBuildBuffer) && !(pBuildNeededChars) )
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sBuild("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pBuildBuffer == nullptr);
		if (isCacheCall) {
			pIDriver->GetVersion(*pMajor, *pMinor, *pMicro, sBuild);

			pIDriver->_setCache (new ParameterCache_4<LibMCDriver_Spinnaker_uint32, LibMCDriver_Spinnaker_uint32, LibMCDriver_Spinnaker_uint32, std::string> (*pMajor, *pMinor, *pMicro, sBuild));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<LibMCDriver_Spinnaker_uint32, LibMCDriver_Spinnaker_uint32, LibMCDriver_Spinnaker_uint32, std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
			cache->retrieveData (*pMajor, *pMinor, *pMicro, sBuild);
			pIDriver->_setCache (nullptr);
		}
		
		if (pBuildNeededChars)
			*pBuildNeededChars = (LibMCDriver_Spinnaker_uint32) (sBuild.size()+1);
		if (pBuildBuffer) {
			if (sBuild.size() >= nBuildBufferSize)
				throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_BUFFERTOOSMALL);
			for (size_t iBuild = 0; iBuild < sBuild.size(); iBuild++)
				pBuildBuffer[iBuild] = sBuild[iBuild];
			pBuildBuffer[sBuild.size()] = 0;
		}
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_driver_queryparameters(LibMCDriver_Spinnaker_Driver pDriver)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pIDriver->QueryParameters();

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_driver_queryparametersex(LibMCDriver_Spinnaker_Driver pDriver, LibMCEnv_DriverStatusUpdateSession pDriverUpdateInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		LibMCEnv::PDriverStatusUpdateSession pIDriverUpdateInstance = std::make_shared<LibMCEnv::CDriverStatusUpdateSession>(CWrapper::sPLibMCEnvWrapper.get(), pDriverUpdateInstance);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverUpdateInstance.get());
		if (!pIDriverUpdateInstance)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pIDriver->QueryParametersEx(pIDriverUpdateInstance);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for SpinnakerDeviceInfo
**************************************************************************************************************************/
LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdeviceinfo_getpropertycount(LibMCDriver_Spinnaker_SpinnakerDeviceInfo pSpinnakerDeviceInfo, LibMCDriver_Spinnaker_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDeviceInfo;

	try {
		if (pCount == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		ISpinnakerDeviceInfo* pISpinnakerDeviceInfo = dynamic_cast<ISpinnakerDeviceInfo*>(pIBaseClass);
		if (!pISpinnakerDeviceInfo)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pCount = pISpinnakerDeviceInfo->GetPropertyCount();

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdeviceinfo_getpropertyname(LibMCDriver_Spinnaker_SpinnakerDeviceInfo pSpinnakerDeviceInfo, LibMCDriver_Spinnaker_uint32 nPropertyIndex, const LibMCDriver_Spinnaker_uint32 nPropertyNameBufferSize, LibMCDriver_Spinnaker_uint32* pPropertyNameNeededChars, char * pPropertyNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDeviceInfo;

	try {
		if ( (!pPropertyNameBuffer) && !(pPropertyNameNeededChars) )
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sPropertyName("");
		ISpinnakerDeviceInfo* pISpinnakerDeviceInfo = dynamic_cast<ISpinnakerDeviceInfo*>(pIBaseClass);
		if (!pISpinnakerDeviceInfo)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPropertyNameBuffer == nullptr);
		if (isCacheCall) {
			sPropertyName = pISpinnakerDeviceInfo->GetPropertyName(nPropertyIndex);

			pISpinnakerDeviceInfo->_setCache (new ParameterCache_1<std::string> (sPropertyName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISpinnakerDeviceInfo->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
			cache->retrieveData (sPropertyName);
			pISpinnakerDeviceInfo->_setCache (nullptr);
		}
		
		if (pPropertyNameNeededChars)
			*pPropertyNameNeededChars = (LibMCDriver_Spinnaker_uint32) (sPropertyName.size()+1);
		if (pPropertyNameBuffer) {
			if (sPropertyName.size() >= nPropertyNameBufferSize)
				throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_BUFFERTOOSMALL);
			for (size_t iPropertyName = 0; iPropertyName < sPropertyName.size(); iPropertyName++)
				pPropertyNameBuffer[iPropertyName] = sPropertyName[iPropertyName];
			pPropertyNameBuffer[sPropertyName.size()] = 0;
		}
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdeviceinfo_getpropertyvalue(LibMCDriver_Spinnaker_SpinnakerDeviceInfo pSpinnakerDeviceInfo, LibMCDriver_Spinnaker_uint32 nPropertyIndex, const LibMCDriver_Spinnaker_uint32 nPropertyValueBufferSize, LibMCDriver_Spinnaker_uint32* pPropertyValueNeededChars, char * pPropertyValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDeviceInfo;

	try {
		if ( (!pPropertyValueBuffer) && !(pPropertyValueNeededChars) )
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sPropertyValue("");
		ISpinnakerDeviceInfo* pISpinnakerDeviceInfo = dynamic_cast<ISpinnakerDeviceInfo*>(pIBaseClass);
		if (!pISpinnakerDeviceInfo)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPropertyValueBuffer == nullptr);
		if (isCacheCall) {
			sPropertyValue = pISpinnakerDeviceInfo->GetPropertyValue(nPropertyIndex);

			pISpinnakerDeviceInfo->_setCache (new ParameterCache_1<std::string> (sPropertyValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISpinnakerDeviceInfo->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
			cache->retrieveData (sPropertyValue);
			pISpinnakerDeviceInfo->_setCache (nullptr);
		}
		
		if (pPropertyValueNeededChars)
			*pPropertyValueNeededChars = (LibMCDriver_Spinnaker_uint32) (sPropertyValue.size()+1);
		if (pPropertyValueBuffer) {
			if (sPropertyValue.size() >= nPropertyValueBufferSize)
				throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_BUFFERTOOSMALL);
			for (size_t iPropertyValue = 0; iPropertyValue < sPropertyValue.size(); iPropertyValue++)
				pPropertyValueBuffer[iPropertyValue] = sPropertyValue[iPropertyValue];
			pPropertyValueBuffer[sPropertyValue.size()] = 0;
		}
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdeviceinfo_getproperty(LibMCDriver_Spinnaker_SpinnakerDeviceInfo pSpinnakerDeviceInfo, LibMCDriver_Spinnaker_uint32 nPropertyIndex, const LibMCDriver_Spinnaker_uint32 nPropertyNameBufferSize, LibMCDriver_Spinnaker_uint32* pPropertyNameNeededChars, char * pPropertyNameBuffer, const LibMCDriver_Spinnaker_uint32 nPropertyValueBufferSize, LibMCDriver_Spinnaker_uint32* pPropertyValueNeededChars, char * pPropertyValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDeviceInfo;

	try {
		if ( (!pPropertyNameBuffer) && !(pPropertyNameNeededChars) )
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if ( (!pPropertyValueBuffer) && !(pPropertyValueNeededChars) )
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sPropertyName("");
		std::string sPropertyValue("");
		ISpinnakerDeviceInfo* pISpinnakerDeviceInfo = dynamic_cast<ISpinnakerDeviceInfo*>(pIBaseClass);
		if (!pISpinnakerDeviceInfo)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPropertyNameBuffer == nullptr) || (pPropertyValueBuffer == nullptr);
		if (isCacheCall) {
			pISpinnakerDeviceInfo->GetProperty(nPropertyIndex, sPropertyName, sPropertyValue);

			pISpinnakerDeviceInfo->_setCache (new ParameterCache_2<std::string, std::string> (sPropertyName, sPropertyValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, std::string>*> (pISpinnakerDeviceInfo->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
			cache->retrieveData (sPropertyName, sPropertyValue);
			pISpinnakerDeviceInfo->_setCache (nullptr);
		}
		
		if (pPropertyNameNeededChars)
			*pPropertyNameNeededChars = (LibMCDriver_Spinnaker_uint32) (sPropertyName.size()+1);
		if (pPropertyNameBuffer) {
			if (sPropertyName.size() >= nPropertyNameBufferSize)
				throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_BUFFERTOOSMALL);
			for (size_t iPropertyName = 0; iPropertyName < sPropertyName.size(); iPropertyName++)
				pPropertyNameBuffer[iPropertyName] = sPropertyName[iPropertyName];
			pPropertyNameBuffer[sPropertyName.size()] = 0;
		}
		if (pPropertyValueNeededChars)
			*pPropertyValueNeededChars = (LibMCDriver_Spinnaker_uint32) (sPropertyValue.size()+1);
		if (pPropertyValueBuffer) {
			if (sPropertyValue.size() >= nPropertyValueBufferSize)
				throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_BUFFERTOOSMALL);
			for (size_t iPropertyValue = 0; iPropertyValue < sPropertyValue.size(); iPropertyValue++)
				pPropertyValueBuffer[iPropertyValue] = sPropertyValue[iPropertyValue];
			pPropertyValueBuffer[sPropertyValue.size()] = 0;
		}
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdeviceinfo_hasproperty(LibMCDriver_Spinnaker_SpinnakerDeviceInfo pSpinnakerDeviceInfo, const char * pPropertyName, bool * pPropertyExists)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDeviceInfo;

	try {
		if (pPropertyName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pPropertyExists == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sPropertyName(pPropertyName);
		ISpinnakerDeviceInfo* pISpinnakerDeviceInfo = dynamic_cast<ISpinnakerDeviceInfo*>(pIBaseClass);
		if (!pISpinnakerDeviceInfo)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pPropertyExists = pISpinnakerDeviceInfo->HasProperty(sPropertyName);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdeviceinfo_findpropertyvalue(LibMCDriver_Spinnaker_SpinnakerDeviceInfo pSpinnakerDeviceInfo, const char * pPropertyName, const LibMCDriver_Spinnaker_uint32 nPropertyValueBufferSize, LibMCDriver_Spinnaker_uint32* pPropertyValueNeededChars, char * pPropertyValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDeviceInfo;

	try {
		if (pPropertyName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if ( (!pPropertyValueBuffer) && !(pPropertyValueNeededChars) )
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sPropertyName(pPropertyName);
		std::string sPropertyValue("");
		ISpinnakerDeviceInfo* pISpinnakerDeviceInfo = dynamic_cast<ISpinnakerDeviceInfo*>(pIBaseClass);
		if (!pISpinnakerDeviceInfo)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPropertyValueBuffer == nullptr);
		if (isCacheCall) {
			pISpinnakerDeviceInfo->FindPropertyValue(sPropertyName, sPropertyValue);

			pISpinnakerDeviceInfo->_setCache (new ParameterCache_1<std::string> (sPropertyValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISpinnakerDeviceInfo->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
			cache->retrieveData (sPropertyValue);
			pISpinnakerDeviceInfo->_setCache (nullptr);
		}
		
		if (pPropertyValueNeededChars)
			*pPropertyValueNeededChars = (LibMCDriver_Spinnaker_uint32) (sPropertyValue.size()+1);
		if (pPropertyValueBuffer) {
			if (sPropertyValue.size() >= nPropertyValueBufferSize)
				throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_BUFFERTOOSMALL);
			for (size_t iPropertyValue = 0; iPropertyValue < sPropertyValue.size(); iPropertyValue++)
				pPropertyValueBuffer[iPropertyValue] = sPropertyValue[iPropertyValue];
			pPropertyValueBuffer[sPropertyValue.size()] = 0;
		}
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for SpinnakerDevice
**************************************************************************************************************************/
LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_close(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pISpinnakerDevice->Close();

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_disconnectandclose(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pISpinnakerDevice->DisconnectAndClose();

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_isopen(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, bool * pDeviceIsOpen)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pDeviceIsOpen == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pDeviceIsOpen = pISpinnakerDevice->IsOpen();

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_getidentifier(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const LibMCDriver_Spinnaker_uint32 nIdentifierBufferSize, LibMCDriver_Spinnaker_uint32* pIdentifierNeededChars, char * pIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if ( (!pIdentifierBuffer) && !(pIdentifierNeededChars) )
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sIdentifier("");
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sIdentifier = pISpinnakerDevice->GetIdentifier();

			pISpinnakerDevice->_setCache (new ParameterCache_1<std::string> (sIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISpinnakerDevice->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
			cache->retrieveData (sIdentifier);
			pISpinnakerDevice->_setCache (nullptr);
		}
		
		if (pIdentifierNeededChars)
			*pIdentifierNeededChars = (LibMCDriver_Spinnaker_uint32) (sIdentifier.size()+1);
		if (pIdentifierBuffer) {
			if (sIdentifier.size() >= nIdentifierBufferSize)
				throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_BUFFERTOOSMALL);
			for (size_t iIdentifier = 0; iIdentifier < sIdentifier.size(); iIdentifier++)
				pIdentifierBuffer[iIdentifier] = sIdentifier[iIdentifier];
			pIdentifierBuffer[sIdentifier.size()] = 0;
		}
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_featureisavailable(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const char * pFeatureName, bool * pIsAvailable)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pIsAvailable == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pIsAvailable = pISpinnakerDevice->FeatureIsAvailable(sFeatureName);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_featureisimplemented(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const char * pFeatureName, bool * pIsImplemented)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pIsImplemented == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pIsImplemented = pISpinnakerDevice->FeatureIsImplemented(sFeatureName);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_featureisreadable(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const char * pFeatureName, bool * pIsReadable)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pIsReadable == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pIsReadable = pISpinnakerDevice->FeatureIsReadable(sFeatureName);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_featureiswriteable(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const char * pFeatureName, bool * pIsWriteable)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pIsWriteable == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pIsWriteable = pISpinnakerDevice->FeatureIsWriteable(sFeatureName);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_setfloatfeature(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const char * pFeatureName, LibMCDriver_Spinnaker_double dFloatValue)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pISpinnakerDevice->SetFloatFeature(sFeatureName, dFloatValue);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_getfloatfeature(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const char * pFeatureName, LibMCDriver_Spinnaker_double * pFloatValue)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pFloatValue == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pFloatValue = pISpinnakerDevice->GetFloatFeature(sFeatureName);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_getfloatfeaturerange(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const char * pFeatureName, LibMCDriver_Spinnaker_double * pMinFloatValue, LibMCDriver_Spinnaker_double * pMaxFloatValue)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (!pMinFloatValue)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (!pMaxFloatValue)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pISpinnakerDevice->GetFloatFeatureRange(sFeatureName, *pMinFloatValue, *pMaxFloatValue);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_setintegerfeature(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const char * pFeatureName, LibMCDriver_Spinnaker_int64 nIntegerValue)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pISpinnakerDevice->SetIntegerFeature(sFeatureName, nIntegerValue);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_getintegerfeature(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const char * pFeatureName, LibMCDriver_Spinnaker_int64 * pIntegerValue)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pIntegerValue == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pIntegerValue = pISpinnakerDevice->GetIntegerFeature(sFeatureName);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_getintegerfeaturerange(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const char * pFeatureName, LibMCDriver_Spinnaker_int64 * pMinIntegerValue, LibMCDriver_Spinnaker_int64 * pMaxIntegerValue)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (!pMinIntegerValue)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (!pMaxIntegerValue)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pISpinnakerDevice->GetIntegerFeatureRange(sFeatureName, *pMinIntegerValue, *pMaxIntegerValue);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_setboolfeature(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const char * pFeatureName, bool bBoolValue)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pISpinnakerDevice->SetBoolFeature(sFeatureName, bBoolValue);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_getboolfeature(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, const char * pFeatureName, bool * pBoolValue)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pBoolValue == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pBoolValue = pISpinnakerDevice->GetBoolFeature(sFeatureName);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_setautoexposure(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, bool bDoAutoExpose)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pISpinnakerDevice->SetAutoExposure(bDoAutoExpose);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_getautoexposure(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, bool * pDoAutoExpose)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pDoAutoExpose == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pDoAutoExpose = pISpinnakerDevice->GetAutoExposure();

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_setexposuretime(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, LibMCDriver_Spinnaker_double dExposureTime)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pISpinnakerDevice->SetExposureTime(dExposureTime);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_getexposuretime(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, LibMCDriver_Spinnaker_double * pExposureTime)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		if (pExposureTime == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pExposureTime = pISpinnakerDevice->GetExposureTime();

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_spinnakerdevice_grabsinglegreyscaleimage(LibMCDriver_Spinnaker_SpinnakerDevice pSpinnakerDevice, LibMCDriver_Spinnaker_uint32 nChannelID, LibMCDriver_Spinnaker_uint32 nTimeoutInMS, LibMCEnv_ImageData pImageInstance)
{
	IBase* pIBaseClass = (IBase *)pSpinnakerDevice;

	try {
		LibMCEnv::PImageData pIImageInstance = std::make_shared<LibMCEnv::CImageData>(CWrapper::sPLibMCEnvWrapper.get(), pImageInstance);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIImageInstance.get());
		if (!pIImageInstance)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		ISpinnakerDevice* pISpinnakerDevice = dynamic_cast<ISpinnakerDevice*>(pIBaseClass);
		if (!pISpinnakerDevice)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pISpinnakerDevice->GrabSingleGreyscaleImage(nChannelID, nTimeoutInMS, pIImageInstance);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Driver_Spinnaker
**************************************************************************************************************************/
LibMCDriver_SpinnakerResult libmcdriver_spinnaker_driver_spinnaker_setcustomsdkresource(LibMCDriver_Spinnaker_Driver_Spinnaker pDriver_Spinnaker, const char * pResourceName)
{
	IBase* pIBaseClass = (IBase *)pDriver_Spinnaker;

	try {
		if (pResourceName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sResourceName(pResourceName);
		IDriver_Spinnaker* pIDriver_Spinnaker = dynamic_cast<IDriver_Spinnaker*>(pIBaseClass);
		if (!pIDriver_Spinnaker)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pIDriver_Spinnaker->SetCustomSDKResource(sResourceName);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_driver_spinnaker_connecttouniquegenericdevice(LibMCDriver_Spinnaker_Driver_Spinnaker pDriver_Spinnaker, const char * pIdentifier, LibMCDriver_Spinnaker_SpinnakerDevice * pDevice)
{
	IBase* pIBaseClass = (IBase *)pDriver_Spinnaker;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pDevice == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseDevice(nullptr);
		IDriver_Spinnaker* pIDriver_Spinnaker = dynamic_cast<IDriver_Spinnaker*>(pIBaseClass);
		if (!pIDriver_Spinnaker)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pBaseDevice = pIDriver_Spinnaker->ConnectToUniqueGenericDevice(sIdentifier);

		*pDevice = (IBase*)(pBaseDevice);
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_driver_spinnaker_connecttouniquegigedevice(LibMCDriver_Spinnaker_Driver_Spinnaker pDriver_Spinnaker, const char * pIdentifier, LibMCDriver_Spinnaker_SpinnakerDevice * pDevice)
{
	IBase* pIBaseClass = (IBase *)pDriver_Spinnaker;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pDevice == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseDevice(nullptr);
		IDriver_Spinnaker* pIDriver_Spinnaker = dynamic_cast<IDriver_Spinnaker*>(pIBaseClass);
		if (!pIDriver_Spinnaker)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pBaseDevice = pIDriver_Spinnaker->ConnectToUniqueGigEDevice(sIdentifier);

		*pDevice = (IBase*)(pBaseDevice);
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_driver_spinnaker_connectionexists(LibMCDriver_Spinnaker_Driver_Spinnaker pDriver_Spinnaker, const char * pIdentifier, bool * pExists)
{
	IBase* pIBaseClass = (IBase *)pDriver_Spinnaker;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pExists == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IDriver_Spinnaker* pIDriver_Spinnaker = dynamic_cast<IDriver_Spinnaker*>(pIBaseClass);
		if (!pIDriver_Spinnaker)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		*pExists = pIDriver_Spinnaker->ConnectionExists(sIdentifier);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_driver_spinnaker_finddeviceconnection(LibMCDriver_Spinnaker_Driver_Spinnaker pDriver_Spinnaker, const char * pIdentifier, LibMCDriver_Spinnaker_SpinnakerDevice * pDevice)
{
	IBase* pIBaseClass = (IBase *)pDriver_Spinnaker;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pDevice == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseDevice(nullptr);
		IDriver_Spinnaker* pIDriver_Spinnaker = dynamic_cast<IDriver_Spinnaker*>(pIBaseClass);
		if (!pIDriver_Spinnaker)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pBaseDevice = pIDriver_Spinnaker->FindDeviceConnection(sIdentifier);

		*pDevice = (IBase*)(pBaseDevice);
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_driver_spinnaker_closeallconnections(LibMCDriver_Spinnaker_Driver_Spinnaker pDriver_Spinnaker)
{
	IBase* pIBaseClass = (IBase *)pDriver_Spinnaker;

	try {
		IDriver_Spinnaker* pIDriver_Spinnaker = dynamic_cast<IDriver_Spinnaker*>(pIBaseClass);
		if (!pIDriver_Spinnaker)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		pIDriver_Spinnaker->CloseAllConnections();

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCDriver_SpinnakerResult LibMCDriver_Spinnaker::Impl::LibMCDriver_Spinnaker_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcdriver_spinnaker_driver_configure") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_driver_configure;
	if (sProcName == "libmcdriver_spinnaker_driver_getname") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_driver_getname;
	if (sProcName == "libmcdriver_spinnaker_driver_gettype") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_driver_gettype;
	if (sProcName == "libmcdriver_spinnaker_driver_getversion") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_driver_getversion;
	if (sProcName == "libmcdriver_spinnaker_driver_queryparameters") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_driver_queryparameters;
	if (sProcName == "libmcdriver_spinnaker_driver_queryparametersex") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_driver_queryparametersex;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdeviceinfo_getpropertycount") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdeviceinfo_getpropertycount;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdeviceinfo_getpropertyname") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdeviceinfo_getpropertyname;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdeviceinfo_getpropertyvalue") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdeviceinfo_getpropertyvalue;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdeviceinfo_getproperty") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdeviceinfo_getproperty;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdeviceinfo_hasproperty") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdeviceinfo_hasproperty;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdeviceinfo_findpropertyvalue") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdeviceinfo_findpropertyvalue;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_close") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_close;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_disconnectandclose") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_disconnectandclose;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_isopen") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_isopen;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_getidentifier") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_getidentifier;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_featureisavailable") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_featureisavailable;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_featureisimplemented") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_featureisimplemented;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_featureisreadable") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_featureisreadable;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_featureiswriteable") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_featureiswriteable;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_setfloatfeature") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_setfloatfeature;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_getfloatfeature") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_getfloatfeature;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_getfloatfeaturerange") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_getfloatfeaturerange;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_setintegerfeature") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_setintegerfeature;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_getintegerfeature") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_getintegerfeature;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_getintegerfeaturerange") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_getintegerfeaturerange;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_setboolfeature") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_setboolfeature;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_getboolfeature") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_getboolfeature;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_setautoexposure") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_setautoexposure;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_getautoexposure") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_getautoexposure;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_setexposuretime") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_setexposuretime;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_getexposuretime") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_getexposuretime;
	if (sProcName == "libmcdriver_spinnaker_spinnakerdevice_grabsinglegreyscaleimage") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_spinnakerdevice_grabsinglegreyscaleimage;
	if (sProcName == "libmcdriver_spinnaker_driver_spinnaker_setcustomsdkresource") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_driver_spinnaker_setcustomsdkresource;
	if (sProcName == "libmcdriver_spinnaker_driver_spinnaker_connecttouniquegenericdevice") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_driver_spinnaker_connecttouniquegenericdevice;
	if (sProcName == "libmcdriver_spinnaker_driver_spinnaker_connecttouniquegigedevice") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_driver_spinnaker_connecttouniquegigedevice;
	if (sProcName == "libmcdriver_spinnaker_driver_spinnaker_connectionexists") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_driver_spinnaker_connectionexists;
	if (sProcName == "libmcdriver_spinnaker_driver_spinnaker_finddeviceconnection") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_driver_spinnaker_finddeviceconnection;
	if (sProcName == "libmcdriver_spinnaker_driver_spinnaker_closeallconnections") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_driver_spinnaker_closeallconnections;
	if (sProcName == "libmcdriver_spinnaker_getversion") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_getversion;
	if (sProcName == "libmcdriver_spinnaker_getlasterror") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_getlasterror;
	if (sProcName == "libmcdriver_spinnaker_releaseinstance") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_releaseinstance;
	if (sProcName == "libmcdriver_spinnaker_acquireinstance") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_acquireinstance;
	if (sProcName == "libmcdriver_spinnaker_injectcomponent") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_injectcomponent;
	if (sProcName == "libmcdriver_spinnaker_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_getsymbollookupmethod;
	if (sProcName == "libmcdriver_spinnaker_createdriver") 
		*ppProcAddress = (void*) &libmcdriver_spinnaker_createdriver;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCDRIVER_SPINNAKER_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCDRIVER_SPINNAKER_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCDriver_SpinnakerResult libmcdriver_spinnaker_getversion(LibMCDriver_Spinnaker_uint32 * pMajor, LibMCDriver_Spinnaker_uint32 * pMinor, LibMCDriver_Spinnaker_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_getlasterror(LibMCDriver_Spinnaker_Base pInstance, const LibMCDriver_Spinnaker_uint32 nErrorMessageBufferSize, LibMCDriver_Spinnaker_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCDriver_Spinnaker_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_releaseinstance(LibMCDriver_Spinnaker_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_acquireinstance(LibMCDriver_Spinnaker_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_injectcomponent(const char * pNameSpace, LibMCDriver_Spinnaker_pvoid pSymbolAddressMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		
		bool bNameSpaceFound = false;
		
		if (sNameSpace == "LibMCEnv") {
			if (CWrapper::sPLibMCEnvWrapper.get() != nullptr) {
				throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_COULDNOTLOADLIBRARY);
			}
			CWrapper::sPLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		
		if (!bNameSpaceFound)
			throw ELibMCDriver_SpinnakerInterfaceException(LIBMCDRIVER_SPINNAKER_ERROR_COULDNOTLOADLIBRARY);
		
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_getsymbollookupmethod(LibMCDriver_Spinnaker_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCDriver_Spinnaker::Impl::LibMCDriver_Spinnaker_GetProcAddress;
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_SpinnakerResult libmcdriver_spinnaker_createdriver(const char * pName, const char * pType, LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCDriver_Spinnaker_Driver * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pType == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		if (pInstance == nullptr)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sType(pType);
		LibMCEnv::PDriverEnvironment pIDriverEnvironment = std::make_shared<LibMCEnv::CDriverEnvironment>(CWrapper::sPLibMCEnvWrapper.get(), pDriverEnvironment);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverEnvironment.get());
		if (!pIDriverEnvironment)
			throw ELibMCDriver_SpinnakerInterfaceException (LIBMCDRIVER_SPINNAKER_ERROR_INVALIDCAST);
		
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateDriver(sName, sType, pIDriverEnvironment);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_SPINNAKER_SUCCESS;
	}
	catch (ELibMCDriver_SpinnakerInterfaceException & Exception) {
		return handleLibMCDriver_SpinnakerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


