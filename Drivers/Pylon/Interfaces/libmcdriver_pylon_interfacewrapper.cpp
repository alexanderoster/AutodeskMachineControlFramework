/*++

Copyright (C) 2025 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of MC Driver Pylon. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 2.0.0

*/

#include "libmcdriver_pylon_abi.hpp"
#include "libmcdriver_pylon_interfaces.hpp"
#include "libmcdriver_pylon_interfaceexception.hpp"

#include <map>

using namespace LibMCDriver_Pylon::Impl;

LibMCDriver_PylonResult handleLibMCDriver_PylonException(IBase * pIBaseClass, ELibMCDriver_PylonInterfaceException & Exception)
{
	LibMCDriver_PylonResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_PylonResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCDriver_PylonResult errorCode = LIBMCDRIVER_PYLON_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_PylonResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCDriver_PylonResult errorCode = LIBMCDRIVER_PYLON_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Driver
**************************************************************************************************************************/
LibMCDriver_PylonResult libmcdriver_pylon_driver_configure(LibMCDriver_Pylon_Driver pDriver, const char * pConfigurationString)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (pConfigurationString == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sConfigurationString(pConfigurationString);
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIDriver->Configure(sConfigurationString);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_driver_getname(LibMCDriver_Pylon_Driver pDriver, const LibMCDriver_Pylon_uint32 nNameBufferSize, LibMCDriver_Pylon_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sName("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIDriver->GetName();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIDriver->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCDriver_Pylon_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_driver_gettype(LibMCDriver_Pylon_Driver pDriver, const LibMCDriver_Pylon_uint32 nTypeBufferSize, LibMCDriver_Pylon_uint32* pTypeNeededChars, char * pTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pTypeBuffer) && !(pTypeNeededChars) )
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sType("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTypeBuffer == nullptr);
		if (isCacheCall) {
			sType = pIDriver->GetType();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
			cache->retrieveData (sType);
			pIDriver->_setCache (nullptr);
		}
		
		if (pTypeNeededChars)
			*pTypeNeededChars = (LibMCDriver_Pylon_uint32) (sType.size()+1);
		if (pTypeBuffer) {
			if (sType.size() >= nTypeBufferSize)
				throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_BUFFERTOOSMALL);
			for (size_t iType = 0; iType < sType.size(); iType++)
				pTypeBuffer[iType] = sType[iType];
			pTypeBuffer[sType.size()] = 0;
		}
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_driver_getversion(LibMCDriver_Pylon_Driver pDriver, LibMCDriver_Pylon_uint32 * pMajor, LibMCDriver_Pylon_uint32 * pMinor, LibMCDriver_Pylon_uint32 * pMicro, const LibMCDriver_Pylon_uint32 nBuildBufferSize, LibMCDriver_Pylon_uint32* pBuildNeededChars, char * pBuildBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (!pMajor)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if ( (!pBuildBuffer) && !(pBuildNeededChars) )
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sBuild("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pBuildBuffer == nullptr);
		if (isCacheCall) {
			pIDriver->GetVersion(*pMajor, *pMinor, *pMicro, sBuild);

			pIDriver->_setCache (new ParameterCache_4<LibMCDriver_Pylon_uint32, LibMCDriver_Pylon_uint32, LibMCDriver_Pylon_uint32, std::string> (*pMajor, *pMinor, *pMicro, sBuild));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<LibMCDriver_Pylon_uint32, LibMCDriver_Pylon_uint32, LibMCDriver_Pylon_uint32, std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
			cache->retrieveData (*pMajor, *pMinor, *pMicro, sBuild);
			pIDriver->_setCache (nullptr);
		}
		
		if (pBuildNeededChars)
			*pBuildNeededChars = (LibMCDriver_Pylon_uint32) (sBuild.size()+1);
		if (pBuildBuffer) {
			if (sBuild.size() >= nBuildBufferSize)
				throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_BUFFERTOOSMALL);
			for (size_t iBuild = 0; iBuild < sBuild.size(); iBuild++)
				pBuildBuffer[iBuild] = sBuild[iBuild];
			pBuildBuffer[sBuild.size()] = 0;
		}
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_driver_queryparameters(LibMCDriver_Pylon_Driver pDriver)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIDriver->QueryParameters();

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_driver_queryparametersex(LibMCDriver_Pylon_Driver pDriver, LibMCEnv_DriverStatusUpdateSession pDriverUpdateInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		LibMCEnv::PDriverStatusUpdateSession pIDriverUpdateInstance = std::make_shared<LibMCEnv::CDriverStatusUpdateSession>(CWrapper::sPLibMCEnvWrapper.get(), pDriverUpdateInstance);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverUpdateInstance.get());
		if (!pIDriverUpdateInstance)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIDriver->QueryParametersEx(pIDriverUpdateInstance);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for PylonDeviceInfo
**************************************************************************************************************************/
LibMCDriver_PylonResult libmcdriver_pylon_pylondeviceinfo_getpropertycount(LibMCDriver_Pylon_PylonDeviceInfo pPylonDeviceInfo, LibMCDriver_Pylon_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pPylonDeviceInfo;

	try {
		if (pCount == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		IPylonDeviceInfo* pIPylonDeviceInfo = dynamic_cast<IPylonDeviceInfo*>(pIBaseClass);
		if (!pIPylonDeviceInfo)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pCount = pIPylonDeviceInfo->GetPropertyCount();

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondeviceinfo_getpropertyname(LibMCDriver_Pylon_PylonDeviceInfo pPylonDeviceInfo, LibMCDriver_Pylon_uint32 nPropertyIndex, const LibMCDriver_Pylon_uint32 nPropertyNameBufferSize, LibMCDriver_Pylon_uint32* pPropertyNameNeededChars, char * pPropertyNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pPylonDeviceInfo;

	try {
		if ( (!pPropertyNameBuffer) && !(pPropertyNameNeededChars) )
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sPropertyName("");
		IPylonDeviceInfo* pIPylonDeviceInfo = dynamic_cast<IPylonDeviceInfo*>(pIBaseClass);
		if (!pIPylonDeviceInfo)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPropertyNameBuffer == nullptr);
		if (isCacheCall) {
			sPropertyName = pIPylonDeviceInfo->GetPropertyName(nPropertyIndex);

			pIPylonDeviceInfo->_setCache (new ParameterCache_1<std::string> (sPropertyName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIPylonDeviceInfo->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
			cache->retrieveData (sPropertyName);
			pIPylonDeviceInfo->_setCache (nullptr);
		}
		
		if (pPropertyNameNeededChars)
			*pPropertyNameNeededChars = (LibMCDriver_Pylon_uint32) (sPropertyName.size()+1);
		if (pPropertyNameBuffer) {
			if (sPropertyName.size() >= nPropertyNameBufferSize)
				throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_BUFFERTOOSMALL);
			for (size_t iPropertyName = 0; iPropertyName < sPropertyName.size(); iPropertyName++)
				pPropertyNameBuffer[iPropertyName] = sPropertyName[iPropertyName];
			pPropertyNameBuffer[sPropertyName.size()] = 0;
		}
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondeviceinfo_getpropertyvalue(LibMCDriver_Pylon_PylonDeviceInfo pPylonDeviceInfo, LibMCDriver_Pylon_uint32 nPropertyIndex, const LibMCDriver_Pylon_uint32 nPropertyValueBufferSize, LibMCDriver_Pylon_uint32* pPropertyValueNeededChars, char * pPropertyValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pPylonDeviceInfo;

	try {
		if ( (!pPropertyValueBuffer) && !(pPropertyValueNeededChars) )
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sPropertyValue("");
		IPylonDeviceInfo* pIPylonDeviceInfo = dynamic_cast<IPylonDeviceInfo*>(pIBaseClass);
		if (!pIPylonDeviceInfo)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPropertyValueBuffer == nullptr);
		if (isCacheCall) {
			sPropertyValue = pIPylonDeviceInfo->GetPropertyValue(nPropertyIndex);

			pIPylonDeviceInfo->_setCache (new ParameterCache_1<std::string> (sPropertyValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIPylonDeviceInfo->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
			cache->retrieveData (sPropertyValue);
			pIPylonDeviceInfo->_setCache (nullptr);
		}
		
		if (pPropertyValueNeededChars)
			*pPropertyValueNeededChars = (LibMCDriver_Pylon_uint32) (sPropertyValue.size()+1);
		if (pPropertyValueBuffer) {
			if (sPropertyValue.size() >= nPropertyValueBufferSize)
				throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_BUFFERTOOSMALL);
			for (size_t iPropertyValue = 0; iPropertyValue < sPropertyValue.size(); iPropertyValue++)
				pPropertyValueBuffer[iPropertyValue] = sPropertyValue[iPropertyValue];
			pPropertyValueBuffer[sPropertyValue.size()] = 0;
		}
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondeviceinfo_getproperty(LibMCDriver_Pylon_PylonDeviceInfo pPylonDeviceInfo, LibMCDriver_Pylon_uint32 nPropertyIndex, const LibMCDriver_Pylon_uint32 nPropertyNameBufferSize, LibMCDriver_Pylon_uint32* pPropertyNameNeededChars, char * pPropertyNameBuffer, const LibMCDriver_Pylon_uint32 nPropertyValueBufferSize, LibMCDriver_Pylon_uint32* pPropertyValueNeededChars, char * pPropertyValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pPylonDeviceInfo;

	try {
		if ( (!pPropertyNameBuffer) && !(pPropertyNameNeededChars) )
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if ( (!pPropertyValueBuffer) && !(pPropertyValueNeededChars) )
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sPropertyName("");
		std::string sPropertyValue("");
		IPylonDeviceInfo* pIPylonDeviceInfo = dynamic_cast<IPylonDeviceInfo*>(pIBaseClass);
		if (!pIPylonDeviceInfo)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPropertyNameBuffer == nullptr) || (pPropertyValueBuffer == nullptr);
		if (isCacheCall) {
			pIPylonDeviceInfo->GetProperty(nPropertyIndex, sPropertyName, sPropertyValue);

			pIPylonDeviceInfo->_setCache (new ParameterCache_2<std::string, std::string> (sPropertyName, sPropertyValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, std::string>*> (pIPylonDeviceInfo->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
			cache->retrieveData (sPropertyName, sPropertyValue);
			pIPylonDeviceInfo->_setCache (nullptr);
		}
		
		if (pPropertyNameNeededChars)
			*pPropertyNameNeededChars = (LibMCDriver_Pylon_uint32) (sPropertyName.size()+1);
		if (pPropertyNameBuffer) {
			if (sPropertyName.size() >= nPropertyNameBufferSize)
				throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_BUFFERTOOSMALL);
			for (size_t iPropertyName = 0; iPropertyName < sPropertyName.size(); iPropertyName++)
				pPropertyNameBuffer[iPropertyName] = sPropertyName[iPropertyName];
			pPropertyNameBuffer[sPropertyName.size()] = 0;
		}
		if (pPropertyValueNeededChars)
			*pPropertyValueNeededChars = (LibMCDriver_Pylon_uint32) (sPropertyValue.size()+1);
		if (pPropertyValueBuffer) {
			if (sPropertyValue.size() >= nPropertyValueBufferSize)
				throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_BUFFERTOOSMALL);
			for (size_t iPropertyValue = 0; iPropertyValue < sPropertyValue.size(); iPropertyValue++)
				pPropertyValueBuffer[iPropertyValue] = sPropertyValue[iPropertyValue];
			pPropertyValueBuffer[sPropertyValue.size()] = 0;
		}
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondeviceinfo_hasproperty(LibMCDriver_Pylon_PylonDeviceInfo pPylonDeviceInfo, const char * pPropertyName, bool * pPropertyExists)
{
	IBase* pIBaseClass = (IBase *)pPylonDeviceInfo;

	try {
		if (pPropertyName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pPropertyExists == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sPropertyName(pPropertyName);
		IPylonDeviceInfo* pIPylonDeviceInfo = dynamic_cast<IPylonDeviceInfo*>(pIBaseClass);
		if (!pIPylonDeviceInfo)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pPropertyExists = pIPylonDeviceInfo->HasProperty(sPropertyName);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondeviceinfo_findpropertyvalue(LibMCDriver_Pylon_PylonDeviceInfo pPylonDeviceInfo, const char * pPropertyName, const LibMCDriver_Pylon_uint32 nPropertyValueBufferSize, LibMCDriver_Pylon_uint32* pPropertyValueNeededChars, char * pPropertyValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pPylonDeviceInfo;

	try {
		if (pPropertyName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if ( (!pPropertyValueBuffer) && !(pPropertyValueNeededChars) )
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sPropertyName(pPropertyName);
		std::string sPropertyValue("");
		IPylonDeviceInfo* pIPylonDeviceInfo = dynamic_cast<IPylonDeviceInfo*>(pIBaseClass);
		if (!pIPylonDeviceInfo)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPropertyValueBuffer == nullptr);
		if (isCacheCall) {
			pIPylonDeviceInfo->FindPropertyValue(sPropertyName, sPropertyValue);

			pIPylonDeviceInfo->_setCache (new ParameterCache_1<std::string> (sPropertyValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIPylonDeviceInfo->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
			cache->retrieveData (sPropertyValue);
			pIPylonDeviceInfo->_setCache (nullptr);
		}
		
		if (pPropertyValueNeededChars)
			*pPropertyValueNeededChars = (LibMCDriver_Pylon_uint32) (sPropertyValue.size()+1);
		if (pPropertyValueBuffer) {
			if (sPropertyValue.size() >= nPropertyValueBufferSize)
				throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_BUFFERTOOSMALL);
			for (size_t iPropertyValue = 0; iPropertyValue < sPropertyValue.size(); iPropertyValue++)
				pPropertyValueBuffer[iPropertyValue] = sPropertyValue[iPropertyValue];
			pPropertyValueBuffer[sPropertyValue.size()] = 0;
		}
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for PylonDevice
**************************************************************************************************************************/
LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_close(LibMCDriver_Pylon_PylonDevice pPylonDevice)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIPylonDevice->Close();

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_disconnectandclose(LibMCDriver_Pylon_PylonDevice pPylonDevice)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIPylonDevice->DisconnectAndClose();

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_isopen(LibMCDriver_Pylon_PylonDevice pPylonDevice, bool * pDeviceIsOpen)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pDeviceIsOpen == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pDeviceIsOpen = pIPylonDevice->IsOpen();

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_getidentifier(LibMCDriver_Pylon_PylonDevice pPylonDevice, const LibMCDriver_Pylon_uint32 nIdentifierBufferSize, LibMCDriver_Pylon_uint32* pIdentifierNeededChars, char * pIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if ( (!pIdentifierBuffer) && !(pIdentifierNeededChars) )
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sIdentifier("");
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sIdentifier = pIPylonDevice->GetIdentifier();

			pIPylonDevice->_setCache (new ParameterCache_1<std::string> (sIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIPylonDevice->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
			cache->retrieveData (sIdentifier);
			pIPylonDevice->_setCache (nullptr);
		}
		
		if (pIdentifierNeededChars)
			*pIdentifierNeededChars = (LibMCDriver_Pylon_uint32) (sIdentifier.size()+1);
		if (pIdentifierBuffer) {
			if (sIdentifier.size() >= nIdentifierBufferSize)
				throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_BUFFERTOOSMALL);
			for (size_t iIdentifier = 0; iIdentifier < sIdentifier.size(); iIdentifier++)
				pIdentifierBuffer[iIdentifier] = sIdentifier[iIdentifier];
			pIdentifierBuffer[sIdentifier.size()] = 0;
		}
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_featureisavailable(LibMCDriver_Pylon_PylonDevice pPylonDevice, const char * pFeatureName, bool * pIsAvailable)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pIsAvailable == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pIsAvailable = pIPylonDevice->FeatureIsAvailable(sFeatureName);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_featureisimplemented(LibMCDriver_Pylon_PylonDevice pPylonDevice, const char * pFeatureName, bool * pIsImplemented)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pIsImplemented == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pIsImplemented = pIPylonDevice->FeatureIsImplemented(sFeatureName);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_featureisreadable(LibMCDriver_Pylon_PylonDevice pPylonDevice, const char * pFeatureName, bool * pIsReadable)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pIsReadable == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pIsReadable = pIPylonDevice->FeatureIsReadable(sFeatureName);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_featureiswriteable(LibMCDriver_Pylon_PylonDevice pPylonDevice, const char * pFeatureName, bool * pIsWriteable)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pIsWriteable == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pIsWriteable = pIPylonDevice->FeatureIsWriteable(sFeatureName);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_setfloatfeature(LibMCDriver_Pylon_PylonDevice pPylonDevice, const char * pFeatureName, LibMCDriver_Pylon_double dFloatValue)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIPylonDevice->SetFloatFeature(sFeatureName, dFloatValue);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_getfloatfeature(LibMCDriver_Pylon_PylonDevice pPylonDevice, const char * pFeatureName, LibMCDriver_Pylon_double * pFloatValue)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pFloatValue == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pFloatValue = pIPylonDevice->GetFloatFeature(sFeatureName);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_getfloatfeaturerange(LibMCDriver_Pylon_PylonDevice pPylonDevice, const char * pFeatureName, LibMCDriver_Pylon_double * pMinFloatValue, LibMCDriver_Pylon_double * pMaxFloatValue)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (!pMinFloatValue)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (!pMaxFloatValue)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIPylonDevice->GetFloatFeatureRange(sFeatureName, *pMinFloatValue, *pMaxFloatValue);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_setintegerfeature(LibMCDriver_Pylon_PylonDevice pPylonDevice, const char * pFeatureName, LibMCDriver_Pylon_int64 nIntegerValue)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIPylonDevice->SetIntegerFeature(sFeatureName, nIntegerValue);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_getintegerfeature(LibMCDriver_Pylon_PylonDevice pPylonDevice, const char * pFeatureName, LibMCDriver_Pylon_int64 * pIntegerValue)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pIntegerValue == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pIntegerValue = pIPylonDevice->GetIntegerFeature(sFeatureName);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_getintegerfeaturerange(LibMCDriver_Pylon_PylonDevice pPylonDevice, const char * pFeatureName, LibMCDriver_Pylon_int64 * pMinIntegerValue, LibMCDriver_Pylon_int64 * pMaxIntegerValue)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (!pMinIntegerValue)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (!pMaxIntegerValue)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIPylonDevice->GetIntegerFeatureRange(sFeatureName, *pMinIntegerValue, *pMaxIntegerValue);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_setboolfeature(LibMCDriver_Pylon_PylonDevice pPylonDevice, const char * pFeatureName, bool bBoolValue)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIPylonDevice->SetBoolFeature(sFeatureName, bBoolValue);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_getboolfeature(LibMCDriver_Pylon_PylonDevice pPylonDevice, const char * pFeatureName, bool * pBoolValue)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pFeatureName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pBoolValue == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sFeatureName(pFeatureName);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pBoolValue = pIPylonDevice->GetBoolFeature(sFeatureName);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_setautoexposure(LibMCDriver_Pylon_PylonDevice pPylonDevice, bool bDoAutoExpose)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIPylonDevice->SetAutoExposure(bDoAutoExpose);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_getautoexposure(LibMCDriver_Pylon_PylonDevice pPylonDevice, bool * pDoAutoExpose)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pDoAutoExpose == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pDoAutoExpose = pIPylonDevice->GetAutoExposure();

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_setexposuretime(LibMCDriver_Pylon_PylonDevice pPylonDevice, LibMCDriver_Pylon_double dExposureTime)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIPylonDevice->SetExposureTime(dExposureTime);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_getexposuretime(LibMCDriver_Pylon_PylonDevice pPylonDevice, LibMCDriver_Pylon_double * pExposureTime)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		if (pExposureTime == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pExposureTime = pIPylonDevice->GetExposureTime();

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_pylondevice_grabsinglegreyscaleimage(LibMCDriver_Pylon_PylonDevice pPylonDevice, LibMCDriver_Pylon_uint32 nChannelID, LibMCDriver_Pylon_uint32 nTimeoutInMS, LibMCEnv_ImageData pImageInstance)
{
	IBase* pIBaseClass = (IBase *)pPylonDevice;

	try {
		LibMCEnv::PImageData pIImageInstance = std::make_shared<LibMCEnv::CImageData>(CWrapper::sPLibMCEnvWrapper.get(), pImageInstance);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIImageInstance.get());
		if (!pIImageInstance)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		IPylonDevice* pIPylonDevice = dynamic_cast<IPylonDevice*>(pIBaseClass);
		if (!pIPylonDevice)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIPylonDevice->GrabSingleGreyscaleImage(nChannelID, nTimeoutInMS, pIImageInstance);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Driver_Pylon
**************************************************************************************************************************/
LibMCDriver_PylonResult libmcdriver_pylon_driver_pylon_setcustomsdkresource(LibMCDriver_Pylon_Driver_Pylon pDriver_Pylon, const char * pResourceName)
{
	IBase* pIBaseClass = (IBase *)pDriver_Pylon;

	try {
		if (pResourceName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sResourceName(pResourceName);
		IDriver_Pylon* pIDriver_Pylon = dynamic_cast<IDriver_Pylon*>(pIBaseClass);
		if (!pIDriver_Pylon)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIDriver_Pylon->SetCustomSDKResource(sResourceName);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_driver_pylon_connecttouniquegenericdevice(LibMCDriver_Pylon_Driver_Pylon pDriver_Pylon, const char * pIdentifier, LibMCDriver_Pylon_PylonDevice * pDevice)
{
	IBase* pIBaseClass = (IBase *)pDriver_Pylon;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pDevice == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseDevice(nullptr);
		IDriver_Pylon* pIDriver_Pylon = dynamic_cast<IDriver_Pylon*>(pIBaseClass);
		if (!pIDriver_Pylon)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pBaseDevice = pIDriver_Pylon->ConnectToUniqueGenericDevice(sIdentifier);

		*pDevice = (IBase*)(pBaseDevice);
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_driver_pylon_connecttouniquegigedevice(LibMCDriver_Pylon_Driver_Pylon pDriver_Pylon, const char * pIdentifier, LibMCDriver_Pylon_PylonDevice * pDevice)
{
	IBase* pIBaseClass = (IBase *)pDriver_Pylon;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pDevice == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseDevice(nullptr);
		IDriver_Pylon* pIDriver_Pylon = dynamic_cast<IDriver_Pylon*>(pIBaseClass);
		if (!pIDriver_Pylon)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pBaseDevice = pIDriver_Pylon->ConnectToUniqueGigEDevice(sIdentifier);

		*pDevice = (IBase*)(pBaseDevice);
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_driver_pylon_connectionexists(LibMCDriver_Pylon_Driver_Pylon pDriver_Pylon, const char * pIdentifier, bool * pExists)
{
	IBase* pIBaseClass = (IBase *)pDriver_Pylon;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pExists == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IDriver_Pylon* pIDriver_Pylon = dynamic_cast<IDriver_Pylon*>(pIBaseClass);
		if (!pIDriver_Pylon)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		*pExists = pIDriver_Pylon->ConnectionExists(sIdentifier);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_driver_pylon_closeallconnections(LibMCDriver_Pylon_Driver_Pylon pDriver_Pylon)
{
	IBase* pIBaseClass = (IBase *)pDriver_Pylon;

	try {
		IDriver_Pylon* pIDriver_Pylon = dynamic_cast<IDriver_Pylon*>(pIBaseClass);
		if (!pIDriver_Pylon)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		pIDriver_Pylon->CloseAllConnections();

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCDriver_PylonResult LibMCDriver_Pylon::Impl::LibMCDriver_Pylon_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcdriver_pylon_driver_configure") 
		*ppProcAddress = (void*) &libmcdriver_pylon_driver_configure;
	if (sProcName == "libmcdriver_pylon_driver_getname") 
		*ppProcAddress = (void*) &libmcdriver_pylon_driver_getname;
	if (sProcName == "libmcdriver_pylon_driver_gettype") 
		*ppProcAddress = (void*) &libmcdriver_pylon_driver_gettype;
	if (sProcName == "libmcdriver_pylon_driver_getversion") 
		*ppProcAddress = (void*) &libmcdriver_pylon_driver_getversion;
	if (sProcName == "libmcdriver_pylon_driver_queryparameters") 
		*ppProcAddress = (void*) &libmcdriver_pylon_driver_queryparameters;
	if (sProcName == "libmcdriver_pylon_driver_queryparametersex") 
		*ppProcAddress = (void*) &libmcdriver_pylon_driver_queryparametersex;
	if (sProcName == "libmcdriver_pylon_pylondeviceinfo_getpropertycount") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondeviceinfo_getpropertycount;
	if (sProcName == "libmcdriver_pylon_pylondeviceinfo_getpropertyname") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondeviceinfo_getpropertyname;
	if (sProcName == "libmcdriver_pylon_pylondeviceinfo_getpropertyvalue") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondeviceinfo_getpropertyvalue;
	if (sProcName == "libmcdriver_pylon_pylondeviceinfo_getproperty") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondeviceinfo_getproperty;
	if (sProcName == "libmcdriver_pylon_pylondeviceinfo_hasproperty") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondeviceinfo_hasproperty;
	if (sProcName == "libmcdriver_pylon_pylondeviceinfo_findpropertyvalue") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondeviceinfo_findpropertyvalue;
	if (sProcName == "libmcdriver_pylon_pylondevice_close") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_close;
	if (sProcName == "libmcdriver_pylon_pylondevice_disconnectandclose") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_disconnectandclose;
	if (sProcName == "libmcdriver_pylon_pylondevice_isopen") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_isopen;
	if (sProcName == "libmcdriver_pylon_pylondevice_getidentifier") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_getidentifier;
	if (sProcName == "libmcdriver_pylon_pylondevice_featureisavailable") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_featureisavailable;
	if (sProcName == "libmcdriver_pylon_pylondevice_featureisimplemented") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_featureisimplemented;
	if (sProcName == "libmcdriver_pylon_pylondevice_featureisreadable") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_featureisreadable;
	if (sProcName == "libmcdriver_pylon_pylondevice_featureiswriteable") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_featureiswriteable;
	if (sProcName == "libmcdriver_pylon_pylondevice_setfloatfeature") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_setfloatfeature;
	if (sProcName == "libmcdriver_pylon_pylondevice_getfloatfeature") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_getfloatfeature;
	if (sProcName == "libmcdriver_pylon_pylondevice_getfloatfeaturerange") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_getfloatfeaturerange;
	if (sProcName == "libmcdriver_pylon_pylondevice_setintegerfeature") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_setintegerfeature;
	if (sProcName == "libmcdriver_pylon_pylondevice_getintegerfeature") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_getintegerfeature;
	if (sProcName == "libmcdriver_pylon_pylondevice_getintegerfeaturerange") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_getintegerfeaturerange;
	if (sProcName == "libmcdriver_pylon_pylondevice_setboolfeature") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_setboolfeature;
	if (sProcName == "libmcdriver_pylon_pylondevice_getboolfeature") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_getboolfeature;
	if (sProcName == "libmcdriver_pylon_pylondevice_setautoexposure") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_setautoexposure;
	if (sProcName == "libmcdriver_pylon_pylondevice_getautoexposure") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_getautoexposure;
	if (sProcName == "libmcdriver_pylon_pylondevice_setexposuretime") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_setexposuretime;
	if (sProcName == "libmcdriver_pylon_pylondevice_getexposuretime") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_getexposuretime;
	if (sProcName == "libmcdriver_pylon_pylondevice_grabsinglegreyscaleimage") 
		*ppProcAddress = (void*) &libmcdriver_pylon_pylondevice_grabsinglegreyscaleimage;
	if (sProcName == "libmcdriver_pylon_driver_pylon_setcustomsdkresource") 
		*ppProcAddress = (void*) &libmcdriver_pylon_driver_pylon_setcustomsdkresource;
	if (sProcName == "libmcdriver_pylon_driver_pylon_connecttouniquegenericdevice") 
		*ppProcAddress = (void*) &libmcdriver_pylon_driver_pylon_connecttouniquegenericdevice;
	if (sProcName == "libmcdriver_pylon_driver_pylon_connecttouniquegigedevice") 
		*ppProcAddress = (void*) &libmcdriver_pylon_driver_pylon_connecttouniquegigedevice;
	if (sProcName == "libmcdriver_pylon_driver_pylon_connectionexists") 
		*ppProcAddress = (void*) &libmcdriver_pylon_driver_pylon_connectionexists;
	if (sProcName == "libmcdriver_pylon_driver_pylon_closeallconnections") 
		*ppProcAddress = (void*) &libmcdriver_pylon_driver_pylon_closeallconnections;
	if (sProcName == "libmcdriver_pylon_getversion") 
		*ppProcAddress = (void*) &libmcdriver_pylon_getversion;
	if (sProcName == "libmcdriver_pylon_getlasterror") 
		*ppProcAddress = (void*) &libmcdriver_pylon_getlasterror;
	if (sProcName == "libmcdriver_pylon_releaseinstance") 
		*ppProcAddress = (void*) &libmcdriver_pylon_releaseinstance;
	if (sProcName == "libmcdriver_pylon_acquireinstance") 
		*ppProcAddress = (void*) &libmcdriver_pylon_acquireinstance;
	if (sProcName == "libmcdriver_pylon_injectcomponent") 
		*ppProcAddress = (void*) &libmcdriver_pylon_injectcomponent;
	if (sProcName == "libmcdriver_pylon_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcdriver_pylon_getsymbollookupmethod;
	if (sProcName == "libmcdriver_pylon_createdriver") 
		*ppProcAddress = (void*) &libmcdriver_pylon_createdriver;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCDRIVER_PYLON_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCDRIVER_PYLON_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCDriver_PylonResult libmcdriver_pylon_getversion(LibMCDriver_Pylon_uint32 * pMajor, LibMCDriver_Pylon_uint32 * pMinor, LibMCDriver_Pylon_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_getlasterror(LibMCDriver_Pylon_Base pInstance, const LibMCDriver_Pylon_uint32 nErrorMessageBufferSize, LibMCDriver_Pylon_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCDriver_Pylon_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_releaseinstance(LibMCDriver_Pylon_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_acquireinstance(LibMCDriver_Pylon_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_injectcomponent(const char * pNameSpace, LibMCDriver_Pylon_pvoid pSymbolAddressMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		
		bool bNameSpaceFound = false;
		
		if (sNameSpace == "LibMCEnv") {
			if (CWrapper::sPLibMCEnvWrapper.get() != nullptr) {
				throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_COULDNOTLOADLIBRARY);
			}
			CWrapper::sPLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		
		if (!bNameSpaceFound)
			throw ELibMCDriver_PylonInterfaceException(LIBMCDRIVER_PYLON_ERROR_COULDNOTLOADLIBRARY);
		
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_getsymbollookupmethod(LibMCDriver_Pylon_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCDriver_Pylon::Impl::LibMCDriver_Pylon_GetProcAddress;
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_PylonResult libmcdriver_pylon_createdriver(const char * pName, const char * pType, LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCDriver_Pylon_Driver * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pType == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		if (pInstance == nullptr)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sType(pType);
		LibMCEnv::PDriverEnvironment pIDriverEnvironment = std::make_shared<LibMCEnv::CDriverEnvironment>(CWrapper::sPLibMCEnvWrapper.get(), pDriverEnvironment);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverEnvironment.get());
		if (!pIDriverEnvironment)
			throw ELibMCDriver_PylonInterfaceException (LIBMCDRIVER_PYLON_ERROR_INVALIDCAST);
		
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateDriver(sName, sType, pIDriverEnvironment);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_PYLON_SUCCESS;
	}
	catch (ELibMCDriver_PylonInterfaceException & Exception) {
		return handleLibMCDriver_PylonException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


